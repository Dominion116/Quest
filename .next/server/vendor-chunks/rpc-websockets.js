"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rpc-websockets";
exports.ids = ["vendor-chunks/rpc-websockets"];
exports.modules = {

/***/ "(ssr)/./node_modules/rpc-websockets/dist/index.cjs":
/*!****************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/index.cjs ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar WebSocketImpl = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/index.js\");\nvar eventemitter3 = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.js\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar uuid = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }\n\nvar WebSocketImpl__default = /*#__PURE__*/_interopDefault(WebSocketImpl);\nvar url__default = /*#__PURE__*/_interopDefault(url);\n\n// src/lib/client/websocket.ts\nfunction WebSocket(address, options) {\n  return new WebSocketImpl__default.default(address, options);\n}\n\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n  encode(value) {\n    return JSON.stringify(value);\n  }\n  decode(value) {\n    return JSON.parse(value);\n  }\n};\n\n// src/lib/client.ts\nvar CommonClient = class extends eventemitter3.EventEmitter {\n  address;\n  rpc_id;\n  queue;\n  options;\n  autoconnect;\n  ready;\n  reconnect;\n  reconnect_timer_id;\n  reconnect_interval;\n  max_reconnects;\n  rest_options;\n  current_reconnects;\n  generate_request_id;\n  socket;\n  webSocketFactory;\n  dataPack;\n  /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */\n  constructor(webSocketFactory, address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id, dataPack) {\n    super();\n    this.webSocketFactory = webSocketFactory;\n    this.queue = {};\n    this.rpc_id = 0;\n    this.address = address;\n    this.autoconnect = autoconnect;\n    this.ready = false;\n    this.reconnect = reconnect;\n    this.reconnect_timer_id = void 0;\n    this.reconnect_interval = reconnect_interval;\n    this.max_reconnects = max_reconnects;\n    this.rest_options = rest_options;\n    this.current_reconnects = 0;\n    this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n    if (!dataPack) this.dataPack = new DefaultDataPack();\n    else this.dataPack = dataPack;\n    if (this.autoconnect)\n      this._connect(this.address, {\n        autoconnect: this.autoconnect,\n        reconnect: this.reconnect,\n        reconnect_interval: this.reconnect_interval,\n        max_reconnects: this.max_reconnects,\n        ...this.rest_options\n      });\n  }\n  /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */\n  connect() {\n    if (this.socket) return;\n    this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */\n  call(method, params, timeout, ws_opts) {\n    if (!ws_opts && \"object\" === typeof timeout) {\n      ws_opts = timeout;\n      timeout = null;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const rpc_id = this.generate_request_id(method, params);\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params: params || void 0,\n        id: rpc_id\n      };\n      this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {\n        if (error) return reject(error);\n        this.queue[rpc_id] = { promise: [resolve, reject] };\n        if (timeout) {\n          this.queue[rpc_id].timeout = setTimeout(() => {\n            delete this.queue[rpc_id];\n            reject(new Error(\"reply timeout\"));\n          }, timeout);\n        }\n      });\n    });\n  }\n  /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */\n  async login(params) {\n    const resp = await this.call(\"rpc.login\", params);\n    if (!resp) throw new Error(\"authentication failed\");\n    return resp;\n  }\n  /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */\n  async listMethods() {\n    return await this.call(\"__listMethods\");\n  }\n  /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */\n  notify(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params\n      };\n      this.socket.send(this.dataPack.encode(message), (error) => {\n        if (error) return reject(error);\n        resolve();\n      });\n    });\n  }\n  /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async subscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.on\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\")\n      throw new Error(\n        \"Failed subscribing to an event '\" + event + \"' with: \" + result[event]\n      );\n    return result;\n  }\n  /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async unsubscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.off\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\")\n      throw new Error(\"Failed unsubscribing from an event with: \" + result);\n    return result;\n  }\n  /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */\n  close(code, data) {\n    if (this.socket) this.socket.close(code || 1e3, data);\n  }\n  /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */\n  setAutoReconnect(reconnect) {\n    this.reconnect = reconnect;\n  }\n  /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */\n  setReconnectInterval(interval) {\n    this.reconnect_interval = interval;\n  }\n  /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */\n  setMaxReconnects(max_reconnects) {\n    this.max_reconnects = max_reconnects;\n  }\n  /**\n  * Get the current number of reconnection attempts made.\n  * @method\n  * @return {Number} current reconnection attempts\n  */\n  getCurrentReconnects() {\n    return this.current_reconnects;\n  }\n  /**\n  * Get the maximum number of reconnection attempts.\n  * @method\n  * @return {Number} maximum reconnection attempts\n  */\n  getMaxReconnects() {\n    return this.max_reconnects;\n  }\n  /**\n  * Check if the client is currently attempting to reconnect.\n  * @method\n  * @return {Boolean} true if reconnection is in progress\n  */\n  isReconnecting() {\n    return this.reconnect_timer_id !== void 0;\n  }\n  /**\n  * Check if the client will attempt to reconnect on the next close event.\n  * @method\n  * @return {Boolean} true if reconnection will be attempted\n  */\n  willReconnect() {\n    return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);\n  }\n  /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */\n  _connect(address, options) {\n    clearTimeout(this.reconnect_timer_id);\n    this.socket = this.webSocketFactory(address, options);\n    this.socket.addEventListener(\"open\", () => {\n      this.ready = true;\n      this.emit(\"open\");\n      this.current_reconnects = 0;\n    });\n    this.socket.addEventListener(\"message\", ({ data: message }) => {\n      if (message instanceof ArrayBuffer)\n        message = Buffer.from(message).toString();\n      try {\n        message = this.dataPack.decode(message);\n      } catch (error) {\n        return;\n      }\n      if (message.notification && this.listeners(message.notification).length) {\n        if (!Object.keys(message.params).length)\n          return this.emit(message.notification);\n        const args = [message.notification];\n        if (message.params.constructor === Object) args.push(message.params);\n        else\n          for (let i = 0; i < message.params.length; i++)\n            args.push(message.params[i]);\n        return Promise.resolve().then(() => {\n          this.emit.apply(this, args);\n        });\n      }\n      if (!this.queue[message.id]) {\n        if (message.method) {\n          return Promise.resolve().then(() => {\n            this.emit(message.method, message?.params);\n          });\n        }\n        return;\n      }\n      if (\"error\" in message === \"result\" in message)\n        this.queue[message.id].promise[1](\n          new Error(\n            'Server response malformed. Response must include either \"result\" or \"error\", but not both.'\n          )\n        );\n      if (this.queue[message.id].timeout)\n        clearTimeout(this.queue[message.id].timeout);\n      if (message.error) this.queue[message.id].promise[1](message.error);\n      else this.queue[message.id].promise[0](message.result);\n      delete this.queue[message.id];\n    });\n    this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error));\n    this.socket.addEventListener(\"close\", ({ code, reason }) => {\n      if (this.ready)\n        setTimeout(() => this.emit(\"close\", code, reason), 0);\n      this.ready = false;\n      this.socket = void 0;\n      if (code === 1e3) return;\n      this.current_reconnects++;\n      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))\n        this.reconnect_timer_id = setTimeout(\n          () => this._connect(address, options),\n          this.reconnect_interval\n        );\n      else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {\n        setTimeout(() => this.emit(\"max_reconnects_reached\", code, reason), 1);\n      }\n    });\n  }\n};\nvar Server = class extends eventemitter3.EventEmitter {\n  namespaces;\n  dataPack;\n  wss;\n  /**\n  * Instantiate a Server class.\n  * @constructor\n  * @param {Object} options - ws constructor's parameters with rpc\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {Server} - returns a new Server instance\n  */\n  constructor(options, dataPack) {\n    super();\n    this.namespaces = {};\n    if (!dataPack) this.dataPack = new DefaultDataPack();\n    else this.dataPack = dataPack;\n    this.wss = new WebSocketImpl.WebSocketServer(options);\n    this.wss.on(\"listening\", () => this.emit(\"listening\"));\n    this.wss.on(\"connection\", (socket, request) => {\n      const u = url__default.default.parse(request.url, true);\n      const ns = u.pathname;\n      if (u.query.socket_id) socket._id = u.query.socket_id;\n      else socket._id = uuid.v1();\n      socket[\"_authenticated\"] = false;\n      socket.on(\"error\", (error) => this.emit(\"socket-error\", socket, error));\n      socket.on(\"close\", () => {\n        this.namespaces[ns].clients.delete(socket._id);\n        for (const event of Object.keys(this.namespaces[ns].events)) {\n          const index = this.namespaces[ns].events[event].sockets.indexOf(\n            socket._id\n          );\n          if (index >= 0)\n            this.namespaces[ns].events[event].sockets.splice(index, 1);\n        }\n        this.emit(\"disconnection\", socket);\n      });\n      if (!this.namespaces[ns]) this._generateNamespace(ns);\n      this.namespaces[ns].clients.set(socket._id, socket);\n      this.emit(\"connection\", socket, request);\n      return this._handleRPC(socket, ns);\n    });\n    this.wss.on(\"error\", (error) => this.emit(\"error\", error));\n  }\n  /**\n  * Registers an RPC method.\n  * @method\n  * @param {String} name - method name\n  * @param {Function} fn - a callee function\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IMethod object\n  */\n  register(name, fn, ns = \"/\") {\n    if (!this.namespaces[ns]) this._generateNamespace(ns);\n    this.namespaces[ns].rpc_methods[name] = {\n      fn,\n      protected: false\n    };\n    return {\n      protected: () => this._makeProtectedMethod(name, ns),\n      public: () => this._makePublicMethod(name, ns)\n    };\n  }\n  /**\n  * Sets an auth method.\n  * @method\n  * @param {Function} fn - an arbitrary auth method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */\n  setAuth(fn, ns = \"/\") {\n    this.register(\"rpc.login\", fn, ns);\n  }\n  /**\n  * Marks an RPC method as protected.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makeProtectedMethod(name, ns = \"/\") {\n    this.namespaces[ns].rpc_methods[name].protected = true;\n  }\n  /**\n  * Marks an RPC method as public.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makePublicMethod(name, ns = \"/\") {\n    this.namespaces[ns].rpc_methods[name].protected = false;\n  }\n  /**\n  * Marks an event as protected.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makeProtectedEvent(name, ns = \"/\") {\n    this.namespaces[ns].events[name].protected = true;\n  }\n  /**\n  * Marks an event as public.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makePublicEvent(name, ns = \"/\") {\n    this.namespaces[ns].events[name].protected = false;\n  }\n  /**\n  * Removes a namespace and closes all connections\n  * @method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */\n  closeNamespace(ns) {\n    const namespace = this.namespaces[ns];\n    if (namespace) {\n      delete namespace.rpc_methods;\n      delete namespace.events;\n      for (const socket of namespace.clients.values()) socket.close();\n      delete this.namespaces[ns];\n    }\n  }\n  /**\n  * Creates a new event that can be emitted to clients.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IEvent object\n  */\n  event(name, ns = \"/\") {\n    if (!this.namespaces[ns]) this._generateNamespace(ns);\n    else {\n      const index = this.namespaces[ns].events[name];\n      if (index !== void 0)\n        throw new Error(`Already registered event ${ns}${name}`);\n    }\n    this.namespaces[ns].events[name] = {\n      sockets: [],\n      protected: false\n    };\n    this.on(name, (...params) => {\n      if (params.length === 1 && params[0] instanceof Object)\n        params = params[0];\n      for (const socket_id of this.namespaces[ns].events[name].sockets) {\n        const socket = this.namespaces[ns].clients.get(socket_id);\n        if (!socket) continue;\n        socket.send(\n          this.dataPack.encode({\n            notification: name,\n            params\n          })\n        );\n      }\n    });\n    return {\n      protected: () => this._makeProtectedEvent(name, ns),\n      public: () => this._makePublicEvent(name, ns)\n    };\n  }\n  /**\n  * Returns a requested namespace object\n  * @method\n  * @param {String} name - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - namespace object\n  */\n  of(name) {\n    if (!this.namespaces[name]) this._generateNamespace(name);\n    const self = this;\n    return {\n      // self.register convenience method\n      register(fn_name, fn) {\n        if (arguments.length !== 2)\n          throw new Error(\"must provide exactly two arguments\");\n        if (typeof fn_name !== \"string\")\n          throw new Error(\"name must be a string\");\n        if (typeof fn !== \"function\")\n          throw new Error(\"handler must be a function\");\n        return self.register(fn_name, fn, name);\n      },\n      // self.event convenience method\n      event(ev_name) {\n        if (arguments.length !== 1)\n          throw new Error(\"must provide exactly one argument\");\n        if (typeof ev_name !== \"string\")\n          throw new Error(\"name must be a string\");\n        return self.event(ev_name, name);\n      },\n      // self.eventList convenience method\n      get eventList() {\n        return Object.keys(self.namespaces[name].events);\n      },\n      /**\n      * Emits a specified event to this namespace.\n      * @inner\n      * @method\n      * @param {String} event - event name\n      * @param {Array} params - event parameters\n      * @return {Undefined}\n      */\n      emit(event, ...params) {\n        const nsEvent = self.namespaces[name].events[event];\n        if (nsEvent)\n          for (const socket_id of nsEvent.sockets) {\n            const socket = self.namespaces[name].clients.get(socket_id);\n            if (!socket) continue;\n            socket.send(\n              self.dataPack.encode({\n                notification: event,\n                params\n              })\n            );\n          }\n      },\n      /**\n      * Returns a name of this namespace.\n      * @inner\n      * @method\n      * @kind constant\n      * @return {String}\n      */\n      get name() {\n        return name;\n      },\n      /**\n      * Returns a hash of websocket objects connected to this namespace.\n      * @inner\n      * @method\n      * @return {Object}\n      */\n      connected() {\n        const socket_ids = [...self.namespaces[name].clients.keys()];\n        return socket_ids.reduce(\n          (acc, curr) => ({\n            ...acc,\n            [curr]: self.namespaces[name].clients.get(curr)\n          }),\n          {}\n        );\n      },\n      /**\n      * Returns a list of client unique identifiers connected to this namespace.\n      * @inner\n      * @method\n      * @return {Array}\n      */\n      clients() {\n        return self.namespaces[name];\n      }\n    };\n  }\n  /**\n  * Lists all created events in a given namespace. Defaults to \"/\".\n  * @method\n  * @param {String} ns - namespaces identifier\n  * @readonly\n  * @return {Array} - returns a list of created events\n  */\n  eventList(ns = \"/\") {\n    if (!this.namespaces[ns]) return [];\n    return Object.keys(this.namespaces[ns].events);\n  }\n  /**\n  * Creates a JSON-RPC 2.0 compliant error\n  * @method\n  * @param {Number} code - indicates the error type that occurred\n  * @param {String} message - provides a short description of the error\n  * @param {String|Object} data - details containing additional information about the error\n  * @return {Object}\n  */\n  createError(code, message, data) {\n    return {\n      code,\n      message,\n      data: data || null\n    };\n  }\n  /**\n  * Closes the server and terminates all clients.\n  * @method\n  * @return {Promise}\n  */\n  close() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.wss.close();\n        this.emit(\"close\");\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /**\n  * Handles all WebSocket JSON RPC 2.0 requests.\n  * @private\n  * @param {Object} socket - ws socket instance\n  * @param {String} ns - namespaces identifier\n  * @return {Undefined}\n  */\n  _handleRPC(socket, ns = \"/\") {\n    socket.on(\"message\", async (data) => {\n      const msg_options = {};\n      if (data instanceof ArrayBuffer) {\n        msg_options.binary = true;\n        data = Buffer.from(data).toString();\n      }\n      if (socket.readyState !== 1) return;\n      let parsedData;\n      try {\n        parsedData = this.dataPack.decode(data);\n      } catch (error) {\n        return socket.send(\n          this.dataPack.encode({\n            jsonrpc: \"2.0\",\n            error: createError(-32700, error.toString()),\n            id: null\n          }),\n          msg_options\n        );\n      }\n      if (Array.isArray(parsedData)) {\n        if (!parsedData.length)\n          return socket.send(\n            this.dataPack.encode({\n              jsonrpc: \"2.0\",\n              error: createError(-32600, \"Invalid array\"),\n              id: null\n            }),\n            msg_options\n          );\n        const responses = [];\n        for (const message of parsedData) {\n          const response2 = await this._runMethod(message, socket._id, ns);\n          if (!response2) continue;\n          responses.push(response2);\n        }\n        if (!responses.length) return;\n        return socket.send(this.dataPack.encode(responses), msg_options);\n      }\n      const response = await this._runMethod(parsedData, socket._id, ns);\n      if (!response) return;\n      return socket.send(this.dataPack.encode(response), msg_options);\n    });\n  }\n  /**\n  * Runs a defined RPC method.\n  * @private\n  * @param {Object} message - a message received\n  * @param {Object} socket_id - user's socket id\n  * @param {String} ns - namespaces identifier\n  * @return {Object|undefined}\n  */\n  async _runMethod(message, socket_id, ns = \"/\") {\n    if (typeof message !== \"object\" || message === null)\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600),\n        id: null\n      };\n    if (message.jsonrpc !== \"2.0\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600, \"Invalid JSON RPC version\"),\n        id: message.id || null\n      };\n    if (!message.method)\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32602, \"Method not specified\"),\n        id: message.id || null\n      };\n    if (typeof message.method !== \"string\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600, \"Invalid method name\"),\n        id: message.id || null\n      };\n    if (message.params && typeof message.params === \"string\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600),\n        id: message.id || null\n      };\n    if (message.method === \"rpc.on\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32e3),\n          id: message.id || null\n        };\n      const results = {};\n      const event_names = Object.keys(this.namespaces[ns].events);\n      for (const name of message.params) {\n        const index = event_names.indexOf(name);\n        const namespace = this.namespaces[ns];\n        if (index === -1) {\n          results[name] = \"provided event invalid\";\n          continue;\n        }\n        if (namespace.events[event_names[index]].protected === true && namespace.clients.get(socket_id)[\"_authenticated\"] === false) {\n          return {\n            jsonrpc: \"2.0\",\n            error: createError(-32606),\n            id: message.id || null\n          };\n        }\n        const socket_index = namespace.events[event_names[index]].sockets.indexOf(socket_id);\n        if (socket_index >= 0) {\n          results[name] = \"socket has already been subscribed to event\";\n          continue;\n        }\n        namespace.events[event_names[index]].sockets.push(socket_id);\n        results[name] = \"ok\";\n      }\n      return {\n        jsonrpc: \"2.0\",\n        result: results,\n        id: message.id || null\n      };\n    } else if (message.method === \"rpc.off\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32e3),\n          id: message.id || null\n        };\n      const results = {};\n      for (const name of message.params) {\n        if (!this.namespaces[ns].events[name]) {\n          results[name] = \"provided event invalid\";\n          continue;\n        }\n        const index = this.namespaces[ns].events[name].sockets.indexOf(socket_id);\n        if (index === -1) {\n          results[name] = \"not subscribed\";\n          continue;\n        }\n        this.namespaces[ns].events[name].sockets.splice(index, 1);\n        results[name] = \"ok\";\n      }\n      return {\n        jsonrpc: \"2.0\",\n        result: results,\n        id: message.id || null\n      };\n    } else if (message.method === \"rpc.login\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32604),\n          id: message.id || null\n        };\n    }\n    if (!this.namespaces[ns].rpc_methods[message.method]) {\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32601),\n        id: message.id || null\n      };\n    }\n    let response = null;\n    if (this.namespaces[ns].rpc_methods[message.method].protected === true && this.namespaces[ns].clients.get(socket_id)[\"_authenticated\"] === false) {\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32605),\n        id: message.id || null\n      };\n    }\n    try {\n      response = await this.namespaces[ns].rpc_methods[message.method].fn(\n        message.params,\n        socket_id\n      );\n    } catch (error) {\n      if (!message.id) return;\n      if (error instanceof Error)\n        return {\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32e3,\n            message: error.name,\n            data: error.message\n          },\n          id: message.id\n        };\n      return {\n        jsonrpc: \"2.0\",\n        error,\n        id: message.id\n      };\n    }\n    if (!message.id) return;\n    if (message.method === \"rpc.login\" && response === true) {\n      const s = this.namespaces[ns].clients.get(socket_id);\n      s[\"_authenticated\"] = true;\n      this.namespaces[ns].clients.set(socket_id, s);\n    }\n    return {\n      jsonrpc: \"2.0\",\n      result: response,\n      id: message.id\n    };\n  }\n  /**\n  * Generate a new namespace store.\n  * Also preregister some special namespace methods.\n  * @private\n  * @param {String} name - namespaces identifier\n  * @return {undefined}\n  */\n  _generateNamespace(name) {\n    this.namespaces[name] = {\n      rpc_methods: {\n        __listMethods: {\n          fn: () => Object.keys(this.namespaces[name].rpc_methods),\n          protected: false\n        }\n      },\n      clients: /* @__PURE__ */ new Map(),\n      events: {}\n    };\n  }\n};\nvar RPC_ERRORS = /* @__PURE__ */ new Map([\n  [-32e3, \"Event not provided\"],\n  [-32600, \"Invalid Request\"],\n  [-32601, \"Method not found\"],\n  [-32602, \"Invalid params\"],\n  [-32603, \"Internal error\"],\n  [-32604, \"Params not found\"],\n  [-32605, \"Method forbidden\"],\n  [-32606, \"Event forbidden\"],\n  [-32700, \"Parse error\"]\n]);\nfunction createError(code, details) {\n  const error = {\n    code,\n    message: RPC_ERRORS.get(code) || \"Internal Server Error\"\n  };\n  if (details) error[\"data\"] = details;\n  return error;\n}\n\n// src/index.ts\nvar Client = class extends CommonClient {\n  constructor(address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id) {\n    super(\n      WebSocket,\n      address,\n      {\n        autoconnect,\n        reconnect,\n        reconnect_interval,\n        max_reconnects,\n        ...rest_options\n      },\n      generate_request_id\n    );\n  }\n};\n\nexports.Client = Client;\nexports.CommonClient = CommonClient;\nexports.DefaultDataPack = DefaultDataPack;\nexports.Server = Server;\nexports.WebSocket = WebSocket;\nexports.createError = createError;\n//# sourceMappingURL=index.cjs.map\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsNENBQUk7QUFDaEMsb0JBQW9CLG1CQUFPLENBQUMsa0VBQWU7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyw4REFBTTs7QUFFekIsK0JBQStCLGlDQUFpQzs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtDQUErQyxlQUFlO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUcsRUFBRSxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nZW9xdWVzdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2luZGV4LmNqcz81MGI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFdlYlNvY2tldEltcGwgPSByZXF1aXJlKCd3cycpO1xudmFyIGV2ZW50ZW1pdHRlcjMgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgV2ViU29ja2V0SW1wbF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoV2ViU29ja2V0SW1wbCk7XG52YXIgdXJsX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdCh1cmwpO1xuXG4vLyBzcmMvbGliL2NsaWVudC93ZWJzb2NrZXQudHNcbmZ1bmN0aW9uIFdlYlNvY2tldChhZGRyZXNzLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgV2ViU29ja2V0SW1wbF9fZGVmYXVsdC5kZWZhdWx0KGFkZHJlc3MsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG52YXIgRGVmYXVsdERhdGFQYWNrID0gY2xhc3Mge1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGRlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9jbGllbnQudHNcbnZhciBDb21tb25DbGllbnQgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcjMuRXZlbnRFbWl0dGVyIHtcbiAgYWRkcmVzcztcbiAgcnBjX2lkO1xuICBxdWV1ZTtcbiAgb3B0aW9ucztcbiAgYXV0b2Nvbm5lY3Q7XG4gIHJlYWR5O1xuICByZWNvbm5lY3Q7XG4gIHJlY29ubmVjdF90aW1lcl9pZDtcbiAgcmVjb25uZWN0X2ludGVydmFsO1xuICBtYXhfcmVjb25uZWN0cztcbiAgcmVzdF9vcHRpb25zO1xuICBjdXJyZW50X3JlY29ubmVjdHM7XG4gIGdlbmVyYXRlX3JlcXVlc3RfaWQ7XG4gIHNvY2tldDtcbiAgd2ViU29ja2V0RmFjdG9yeTtcbiAgZGF0YVBhY2s7XG4gIC8qKlxuICAqIEluc3RhbnRpYXRlIGEgQ2xpZW50IGNsYXNzLlxuICAqIEBjb25zdHJ1Y3RvclxuICAqIEBwYXJhbSB7d2ViU29ja2V0RmFjdG9yeX0gd2ViU29ja2V0RmFjdG9yeSAtIGZhY3RvcnkgbWV0aG9kIGZvciBXZWJTb2NrZXRcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHVybCB0byBhIHdlYnNvY2tldCBzZXJ2ZXJcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIG9wdGlvbnMgb2JqZWN0IHdpdGggcmVjb25uZWN0IHBhcmFtZXRlcnNcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZW5lcmF0ZV9yZXF1ZXN0X2lkIC0gY3VzdG9tIGdlbmVyYXRpb24gcmVxdWVzdCBJZFxuICAqIEBwYXJhbSB7RGF0YVBhY2t9IGRhdGFQYWNrIC0gZGF0YSBwYWNrIGNvbnRhaW5zIGVuY29kZXIgYW5kIGRlY29kZXJcbiAgKiBAcmV0dXJuIHtDb21tb25DbGllbnR9XG4gICovXG4gIGNvbnN0cnVjdG9yKHdlYlNvY2tldEZhY3RvcnksIGFkZHJlc3MgPSBcIndzOi8vbG9jYWxob3N0OjgwODBcIiwge1xuICAgIGF1dG9jb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdF9pbnRlcnZhbCA9IDFlMyxcbiAgICBtYXhfcmVjb25uZWN0cyA9IDUsXG4gICAgLi4ucmVzdF9vcHRpb25zXG4gIH0gPSB7fSwgZ2VuZXJhdGVfcmVxdWVzdF9pZCwgZGF0YVBhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgdGhpcy5xdWV1ZSA9IHt9O1xuICAgIHRoaXMucnBjX2lkID0gMDtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMuYXV0b2Nvbm5lY3QgPSBhdXRvY29ubmVjdDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3Q7XG4gICAgdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwgPSByZWNvbm5lY3RfaW50ZXJ2YWw7XG4gICAgdGhpcy5tYXhfcmVjb25uZWN0cyA9IG1heF9yZWNvbm5lY3RzO1xuICAgIHRoaXMucmVzdF9vcHRpb25zID0gcmVzdF9vcHRpb25zO1xuICAgIHRoaXMuY3VycmVudF9yZWNvbm5lY3RzID0gMDtcbiAgICB0aGlzLmdlbmVyYXRlX3JlcXVlc3RfaWQgPSBnZW5lcmF0ZV9yZXF1ZXN0X2lkIHx8ICgoKSA9PiB0eXBlb2YgdGhpcy5ycGNfaWQgPT09IFwibnVtYmVyXCIgPyArK3RoaXMucnBjX2lkIDogTnVtYmVyKHRoaXMucnBjX2lkKSArIDEpO1xuICAgIGlmICghZGF0YVBhY2spIHRoaXMuZGF0YVBhY2sgPSBuZXcgRGVmYXVsdERhdGFQYWNrKCk7XG4gICAgZWxzZSB0aGlzLmRhdGFQYWNrID0gZGF0YVBhY2s7XG4gICAgaWYgKHRoaXMuYXV0b2Nvbm5lY3QpXG4gICAgICB0aGlzLl9jb25uZWN0KHRoaXMuYWRkcmVzcywge1xuICAgICAgICBhdXRvY29ubmVjdDogdGhpcy5hdXRvY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0OiB0aGlzLnJlY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0X2ludGVydmFsOiB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgICAgbWF4X3JlY29ubmVjdHM6IHRoaXMubWF4X3JlY29ubmVjdHMsXG4gICAgICAgIC4uLnRoaXMucmVzdF9vcHRpb25zXG4gICAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBDb25uZWN0cyB0byBhIGRlZmluZWQgc2VydmVyIGlmIG5vdCBjb25uZWN0ZWQgYWxyZWFkeS5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnNvY2tldCkgcmV0dXJuO1xuICAgIHRoaXMuX2Nvbm5lY3QodGhpcy5hZGRyZXNzLCB7XG4gICAgICBhdXRvY29ubmVjdDogdGhpcy5hdXRvY29ubmVjdCxcbiAgICAgIHJlY29ubmVjdDogdGhpcy5yZWNvbm5lY3QsXG4gICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IHRoaXMucmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IHRoaXMubWF4X3JlY29ubmVjdHMsXG4gICAgICAuLi50aGlzLnJlc3Rfb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIENhbGxzIGEgcmVnaXN0ZXJlZCBSUEMgbWV0aG9kIG9uIHNlcnZlci5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFJQQyBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBwYXJhbXMgLSBvcHRpb25hbCBtZXRob2QgcGFyYW1ldGVyc1xuICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IC0gUlBDIHJlcGx5IHRpbWVvdXQgdmFsdWVcbiAgKiBAcGFyYW0ge09iamVjdH0gd3Nfb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIHdzXG4gICogQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgY2FsbChtZXRob2QsIHBhcmFtcywgdGltZW91dCwgd3Nfb3B0cykge1xuICAgIGlmICghd3Nfb3B0cyAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdGltZW91dCkge1xuICAgICAgd3Nfb3B0cyA9IHRpbWVvdXQ7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5yZWFkeSkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJzb2NrZXQgbm90IHJlYWR5XCIpKTtcbiAgICAgIGNvbnN0IHJwY19pZCA9IHRoaXMuZ2VuZXJhdGVfcmVxdWVzdF9pZChtZXRob2QsIHBhcmFtcyk7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtczogcGFyYW1zIHx8IHZvaWQgMCxcbiAgICAgICAgaWQ6IHJwY19pZFxuICAgICAgfTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUobWVzc2FnZSksIHdzX29wdHMsIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLnF1ZXVlW3JwY19pZF0gPSB7IHByb21pc2U6IFtyZXNvbHZlLCByZWplY3RdIH07XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZVtycGNfaWRdLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlW3JwY19pZF07XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwicmVwbHkgdGltZW91dFwiKSk7XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIExvZ2lucyB3aXRoIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBjb25uZWN0aW9uLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gTG9naW4gY3JlZGVudGlhbHMgb2JqZWN0XG4gICogQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgYXN5bmMgbG9naW4ocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5sb2dpblwiLCBwYXJhbXMpO1xuICAgIGlmICghcmVzcCkgdGhyb3cgbmV3IEVycm9yKFwiYXV0aGVudGljYXRpb24gZmFpbGVkXCIpO1xuICAgIHJldHVybiByZXNwO1xuICB9XG4gIC8qKlxuICAqIEZldGNoZXMgYSBsaXN0IG9mIGNsaWVudCdzIG1ldGhvZHMgcmVnaXN0ZXJlZCBvbiBzZXJ2ZXIuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge0FycmF5fVxuICAqL1xuICBhc3luYyBsaXN0TWV0aG9kcygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jYWxsKFwiX19saXN0TWV0aG9kc1wiKTtcbiAgfVxuICAvKipcbiAgKiBTZW5kcyBhIEpTT04tUlBDIDIuMCBub3RpZmljYXRpb24gdG8gc2VydmVyLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gUlBDIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIG9wdGlvbmFsIG1ldGhvZCBwYXJhbWV0ZXJzXG4gICogQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgbm90aWZ5KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5yZWFkeSkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJzb2NrZXQgbm90IHJlYWR5XCIpKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9O1xuICAgICAgdGhpcy5zb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShtZXNzYWdlKSwgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIFN1YnNjcmliZXMgZm9yIGEgZGVmaW5lZCBldmVudC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgKi9cbiAgYXN5bmMgc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikgZXZlbnQgPSBbZXZlbnRdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5vblwiLCBldmVudCk7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIiAmJiByZXN1bHRbZXZlbnRdICE9PSBcIm9rXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHN1YnNjcmliaW5nIHRvIGFuIGV2ZW50ICdcIiArIGV2ZW50ICsgXCInIHdpdGg6IFwiICsgcmVzdWx0W2V2ZW50XVxuICAgICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAqIFVuc3Vic2NyaWJlcyBmcm9tIGEgZGVmaW5lZCBldmVudC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgKi9cbiAgYXN5bmMgdW5zdWJzY3JpYmUoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSBldmVudCA9IFtldmVudF07XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsKFwicnBjLm9mZlwiLCBldmVudCk7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIiAmJiByZXN1bHRbZXZlbnRdICE9PSBcIm9rXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdW5zdWJzY3JpYmluZyBmcm9tIGFuIGV2ZW50IHdpdGg6IFwiICsgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAqIENsb3NlcyBhIFdlYlNvY2tldCBjb25uZWN0aW9uIGdyYWNlZnVsbHkuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIC0gc29ja2V0IGNsb3NlIGNvZGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSAtIG9wdGlvbmFsIGRhdGEgdG8gYmUgc2VudCBiZWZvcmUgY2xvc2luZ1xuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnNvY2tldCkgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSB8fCAxZTMsIGRhdGEpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZSAvIGRpc2FibGUgYXV0b21hdGljIHJlY29ubmVjdGlvbi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtCb29sZWFufSByZWNvbm5lY3QgLSBlbmFibGUgLyBkaXNhYmxlIHJlY29ubmVjdGlvblxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0QXV0b1JlY29ubmVjdChyZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCA9IHJlY29ubmVjdDtcbiAgfVxuICAvKipcbiAgKiBTZXQgdGhlIGludGVydmFsIGJldHdlZW4gcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWwgLSByZWNvbm5lY3Rpb24gaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRSZWNvbm5lY3RJbnRlcnZhbChpbnRlcnZhbCkge1xuICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gaW50ZXJ2YWw7XG4gIH1cbiAgLyoqXG4gICogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhfcmVjb25uZWN0cyAtIG1heGltdW0gcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRNYXhSZWNvbm5lY3RzKG1heF9yZWNvbm5lY3RzKSB7XG4gICAgdGhpcy5tYXhfcmVjb25uZWN0cyA9IG1heF9yZWNvbm5lY3RzO1xuICB9XG4gIC8qKlxuICAqIEdldCB0aGUgY3VycmVudCBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzIG1hZGUuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge051bWJlcn0gY3VycmVudCByZWNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgKi9cbiAgZ2V0Q3VycmVudFJlY29ubmVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudF9yZWNvbm5lY3RzO1xuICB9XG4gIC8qKlxuICAqIEdldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1heGltdW0gcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICovXG4gIGdldE1heFJlY29ubmVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4X3JlY29ubmVjdHM7XG4gIH1cbiAgLyoqXG4gICogQ2hlY2sgaWYgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgYXR0ZW1wdGluZyB0byByZWNvbm5lY3QuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcmVjb25uZWN0aW9uIGlzIGluIHByb2dyZXNzXG4gICovXG4gIGlzUmVjb25uZWN0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29ubmVjdF90aW1lcl9pZCAhPT0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAqIENoZWNrIGlmIHRoZSBjbGllbnQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCBvbiB0aGUgbmV4dCBjbG9zZSBldmVudC5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiByZWNvbm5lY3Rpb24gd2lsbCBiZSBhdHRlbXB0ZWRcbiAgKi9cbiAgd2lsbFJlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3QgJiYgKHRoaXMubWF4X3JlY29ubmVjdHMgPT09IDAgfHwgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPCB0aGlzLm1heF9yZWNvbm5lY3RzKTtcbiAgfVxuICAvKipcbiAgKiBDb25uZWN0aW9uL01lc3NhZ2UgaGFuZGxlci5cbiAgKiBAbWV0aG9kXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIFdlYlNvY2tldCBBUEkgYWRkcmVzc1xuICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gd3Mgb3B0aW9ucyBvYmplY3RcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9jb25uZWN0KGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RfdGltZXJfaWQpO1xuICAgIHRoaXMuc29ja2V0ID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5KGFkZHJlc3MsIG9wdGlvbnMpO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgICAgIHRoaXMuY3VycmVudF9yZWNvbm5lY3RzID0gMDtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoeyBkYXRhOiBtZXNzYWdlIH0pID0+IHtcbiAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKS50b1N0cmluZygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMuZGF0YVBhY2suZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uubm90aWZpY2F0aW9uICYmIHRoaXMubGlzdGVuZXJzKG1lc3NhZ2Uubm90aWZpY2F0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhtZXNzYWdlLnBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQobWVzc2FnZS5ub3RpZmljYXRpb24pO1xuICAgICAgICBjb25zdCBhcmdzID0gW21lc3NhZ2Uubm90aWZpY2F0aW9uXTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UucGFyYW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgYXJncy5wdXNoKG1lc3NhZ2UucGFyYW1zW2ldKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucXVldWVbbWVzc2FnZS5pZF0pIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlPy5wYXJhbXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChcImVycm9yXCIgaW4gbWVzc2FnZSA9PT0gXCJyZXN1bHRcIiBpbiBtZXNzYWdlKVxuICAgICAgICB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnByb21pc2VbMV0oXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1NlcnZlciByZXNwb25zZSBtYWxmb3JtZWQuIFJlc3BvbnNlIG11c3QgaW5jbHVkZSBlaXRoZXIgXCJyZXN1bHRcIiBvciBcImVycm9yXCIsIGJ1dCBub3QgYm90aC4nXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgaWYgKHRoaXMucXVldWVbbWVzc2FnZS5pZF0udGltZW91dClcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucXVldWVbbWVzc2FnZS5pZF0udGltZW91dCk7XG4gICAgICBpZiAobWVzc2FnZS5lcnJvcikgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzFdKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgZWxzZSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnByb21pc2VbMF0obWVzc2FnZS5yZXN1bHQpO1xuICAgICAgZGVsZXRlIHRoaXMucXVldWVbbWVzc2FnZS5pZF07XG4gICAgfSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlcnJvcikgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpKTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKHsgY29kZSwgcmVhc29uIH0pID0+IHtcbiAgICAgIGlmICh0aGlzLnJlYWR5KVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZW1pdChcImNsb3NlXCIsIGNvZGUsIHJlYXNvbiksIDApO1xuICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5zb2NrZXQgPSB2b2lkIDA7XG4gICAgICBpZiAoY29kZSA9PT0gMWUzKSByZXR1cm47XG4gICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cysrO1xuICAgICAgaWYgKHRoaXMucmVjb25uZWN0ICYmICh0aGlzLm1heF9yZWNvbm5lY3RzID4gdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgfHwgdGhpcy5tYXhfcmVjb25uZWN0cyA9PT0gMCkpXG4gICAgICAgIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkID0gc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiB0aGlzLl9jb25uZWN0KGFkZHJlc3MsIG9wdGlvbnMpLFxuICAgICAgICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsXG4gICAgICAgICk7XG4gICAgICBlbHNlIGlmICh0aGlzLnJlY29ubmVjdCAmJiB0aGlzLm1heF9yZWNvbm5lY3RzID4gMCAmJiB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA+PSB0aGlzLm1heF9yZWNvbm5lY3RzKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbWl0KFwibWF4X3JlY29ubmVjdHNfcmVhY2hlZFwiLCBjb2RlLCByZWFzb24pLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBTZXJ2ZXIgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcjMuRXZlbnRFbWl0dGVyIHtcbiAgbmFtZXNwYWNlcztcbiAgZGF0YVBhY2s7XG4gIHdzcztcbiAgLyoqXG4gICogSW5zdGFudGlhdGUgYSBTZXJ2ZXIgY2xhc3MuXG4gICogQGNvbnN0cnVjdG9yXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBjb25zdHJ1Y3RvcidzIHBhcmFtZXRlcnMgd2l0aCBycGNcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7U2VydmVyfSAtIHJldHVybnMgYSBuZXcgU2VydmVyIGluc3RhbmNlXG4gICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWVzcGFjZXMgPSB7fTtcbiAgICBpZiAoIWRhdGFQYWNrKSB0aGlzLmRhdGFQYWNrID0gbmV3IERlZmF1bHREYXRhUGFjaygpO1xuICAgIGVsc2UgdGhpcy5kYXRhUGFjayA9IGRhdGFQYWNrO1xuICAgIHRoaXMud3NzID0gbmV3IFdlYlNvY2tldEltcGwuV2ViU29ja2V0U2VydmVyKG9wdGlvbnMpO1xuICAgIHRoaXMud3NzLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHRoaXMuZW1pdChcImxpc3RlbmluZ1wiKSk7XG4gICAgdGhpcy53c3Mub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQsIHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IHUgPSB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShyZXF1ZXN0LnVybCwgdHJ1ZSk7XG4gICAgICBjb25zdCBucyA9IHUucGF0aG5hbWU7XG4gICAgICBpZiAodS5xdWVyeS5zb2NrZXRfaWQpIHNvY2tldC5faWQgPSB1LnF1ZXJ5LnNvY2tldF9pZDtcbiAgICAgIGVsc2Ugc29ja2V0Ll9pZCA9IHV1aWQudjEoKTtcbiAgICAgIHNvY2tldFtcIl9hdXRoZW50aWNhdGVkXCJdID0gZmFsc2U7XG4gICAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcInNvY2tldC1lcnJvclwiLCBzb2NrZXQsIGVycm9yKSk7XG4gICAgICBzb2NrZXQub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5kZWxldGUoc29ja2V0Ll9pZCk7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tldmVudF0uc29ja2V0cy5pbmRleE9mKFxuICAgICAgICAgICAgc29ja2V0Ll9pZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApXG4gICAgICAgICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tldmVudF0uc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuc2V0KHNvY2tldC5faWQsIHNvY2tldCk7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCwgcmVxdWVzdCk7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlUlBDKHNvY2tldCwgbnMpO1xuICAgIH0pO1xuICAgIHRoaXMud3NzLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICB9XG4gIC8qKlxuICAqIFJlZ2lzdGVycyBhbiBSUEMgbWV0aG9kLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBhIGNhbGxlZSBmdW5jdGlvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5zIGFuIElNZXRob2Qgb2JqZWN0XG4gICovXG4gIHJlZ2lzdGVyKG5hbWUsIGZuLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1tuYW1lXSA9IHtcbiAgICAgIGZuLFxuICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RlY3RlZDogKCkgPT4gdGhpcy5fbWFrZVByb3RlY3RlZE1ldGhvZChuYW1lLCBucyksXG4gICAgICBwdWJsaWM6ICgpID0+IHRoaXMuX21ha2VQdWJsaWNNZXRob2QobmFtZSwgbnMpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBTZXRzIGFuIGF1dGggbWV0aG9kLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGFuIGFyYml0cmFyeSBhdXRoIG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0QXV0aChmbiwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMucmVnaXN0ZXIoXCJycGMubG9naW5cIiwgZm4sIG5zKTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBSUEMgbWV0aG9kIGFzIHByb3RlY3RlZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVByb3RlY3RlZE1ldGhvZChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1tuYW1lXS5wcm90ZWN0ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIFJQQyBtZXRob2QgYXMgcHVibGljLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHVibGljTWV0aG9kKG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdLnByb3RlY3RlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIGV2ZW50IGFzIHByb3RlY3RlZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHJvdGVjdGVkRXZlbnQobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnByb3RlY3RlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gZXZlbnQgYXMgcHVibGljLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGV2ZW50IG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQdWJsaWNFdmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0ucHJvdGVjdGVkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogUmVtb3ZlcyBhIG5hbWVzcGFjZSBhbmQgY2xvc2VzIGFsbCBjb25uZWN0aW9uc1xuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNsb3NlTmFtZXNwYWNlKG5zKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICBkZWxldGUgbmFtZXNwYWNlLnJwY19tZXRob2RzO1xuICAgICAgZGVsZXRlIG5hbWVzcGFjZS5ldmVudHM7XG4gICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiBuYW1lc3BhY2UuY2xpZW50cy52YWx1ZXMoKSkgc29ja2V0LmNsb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIG5ldyBldmVudCB0aGF0IGNhbiBiZSBlbWl0dGVkIHRvIGNsaWVudHMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZXZlbnQgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5zIGFuIElFdmVudCBvYmplY3RcbiAgKi9cbiAgZXZlbnQobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobnMpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXTtcbiAgICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgcmVnaXN0ZXJlZCBldmVudCAke25zfSR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0gPSB7XG4gICAgICBzb2NrZXRzOiBbXSxcbiAgICAgIHByb3RlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMub24obmFtZSwgKC4uLnBhcmFtcykgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEgJiYgcGFyYW1zWzBdIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXNbMF07XG4gICAgICBmb3IgKGNvbnN0IHNvY2tldF9pZCBvZiB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5zb2NrZXRzKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKCFzb2NrZXQpIGNvbnRpbnVlO1xuICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICB0aGlzLmRhdGFQYWNrLmVuY29kZSh7XG4gICAgICAgICAgICBub3RpZmljYXRpb246IG5hbWUsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwcm90ZWN0ZWQ6ICgpID0+IHRoaXMuX21ha2VQcm90ZWN0ZWRFdmVudChuYW1lLCBucyksXG4gICAgICBwdWJsaWM6ICgpID0+IHRoaXMuX21ha2VQdWJsaWNFdmVudChuYW1lLCBucylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgYSByZXF1ZXN0ZWQgbmFtZXNwYWNlIG9iamVjdFxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSBuYW1lc3BhY2Ugb2JqZWN0XG4gICovXG4gIG9mKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuYW1lXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobmFtZSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIHNlbGYucmVnaXN0ZXIgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICByZWdpc3Rlcihmbl9uYW1lLCBmbikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHByb3ZpZGUgZXhhY3RseSB0d28gYXJndW1lbnRzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZuX25hbWUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBzZWxmLnJlZ2lzdGVyKGZuX25hbWUsIGZuLCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICAvLyBzZWxmLmV2ZW50IGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAgZXZlbnQoZXZfbmFtZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHByb3ZpZGUgZXhhY3RseSBvbmUgYXJndW1lbnRcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZXZfbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBzZWxmLmV2ZW50KGV2X25hbWUsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNlbGYuZXZlbnRMaXN0IGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAgZ2V0IGV2ZW50TGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNlbGYubmFtZXNwYWNlc1tuYW1lXS5ldmVudHMpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBFbWl0cyBhIHNwZWNpZmllZCBldmVudCB0byB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgLSBldmVudCBwYXJhbWV0ZXJzXG4gICAgICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICAgICovXG4gICAgICBlbWl0KGV2ZW50LCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbnNFdmVudCA9IHNlbGYubmFtZXNwYWNlc1tuYW1lXS5ldmVudHNbZXZlbnRdO1xuICAgICAgICBpZiAobnNFdmVudClcbiAgICAgICAgICBmb3IgKGNvbnN0IHNvY2tldF9pZCBvZiBuc0V2ZW50LnNvY2tldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHNlbGYubmFtZXNwYWNlc1tuYW1lXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgICAgICAgaWYgKCFzb2NrZXQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoXG4gICAgICAgICAgICAgIHNlbGYuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb246IGV2ZW50LFxuICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBuYW1lIG9mIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAa2luZCBjb25zdGFudFxuICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAqL1xuICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBSZXR1cm5zIGEgaGFzaCBvZiB3ZWJzb2NrZXQgb2JqZWN0cyBjb25uZWN0ZWQgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICovXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldF9pZHMgPSBbLi4uc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMua2V5cygpXTtcbiAgICAgICAgcmV0dXJuIHNvY2tldF9pZHMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIGN1cnIpID0+ICh7XG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICBbY3Vycl06IHNlbGYubmFtZXNwYWNlc1tuYW1lXS5jbGllbnRzLmdldChjdXJyKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNsaWVudCB1bmlxdWUgaWRlbnRpZmllcnMgY29ubmVjdGVkIHRvIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICovXG4gICAgICBjbGllbnRzKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5uYW1lc3BhY2VzW25hbWVdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogTGlzdHMgYWxsIGNyZWF0ZWQgZXZlbnRzIGluIGEgZ2l2ZW4gbmFtZXNwYWNlLiBEZWZhdWx0cyB0byBcIi9cIi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJlYWRvbmx5XG4gICogQHJldHVybiB7QXJyYXl9IC0gcmV0dXJucyBhIGxpc3Qgb2YgY3JlYXRlZCBldmVudHNcbiAgKi9cbiAgZXZlbnRMaXN0KG5zID0gXCIvXCIpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHJldHVybiBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpO1xuICB9XG4gIC8qKlxuICAqIENyZWF0ZXMgYSBKU09OLVJQQyAyLjAgY29tcGxpYW50IGVycm9yXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIC0gaW5kaWNhdGVzIHRoZSBlcnJvciB0eXBlIHRoYXQgb2NjdXJyZWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHByb3ZpZGVzIGEgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yXG4gICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhIC0gZGV0YWlscyBjb250YWluaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqL1xuICBjcmVhdGVFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YTogZGF0YSB8fCBudWxsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBDbG9zZXMgdGhlIHNlcnZlciBhbmQgdGVybWluYXRlcyBhbGwgY2xpZW50cy5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3NzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEhhbmRsZXMgYWxsIFdlYlNvY2tldCBKU09OIFJQQyAyLjAgcmVxdWVzdHMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IC0gd3Mgc29ja2V0IGluc3RhbmNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfaGFuZGxlUlBDKHNvY2tldCwgbnMgPSBcIi9cIikge1xuICAgIHNvY2tldC5vbihcIm1lc3NhZ2VcIiwgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IG1zZ19vcHRpb25zID0ge307XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIG1zZ19vcHRpb25zLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSByZXR1cm47XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSB0aGlzLmRhdGFQYWNrLmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBzb2NrZXQuc2VuZChcbiAgICAgICAgICB0aGlzLmRhdGFQYWNrLmVuY29kZSh7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjcwMCwgZXJyb3IudG9TdHJpbmcoKSksXG4gICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1zZ19vcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWREYXRhKSkge1xuICAgICAgICBpZiAoIXBhcnNlZERhdGEubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCwgXCJJbnZhbGlkIGFycmF5XCIpLFxuICAgICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtc2dfb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyc2VkRGF0YSkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IHRoaXMuX3J1bk1ldGhvZChtZXNzYWdlLCBzb2NrZXQuX2lkLCBucyk7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZTIpIGNvbnRpbnVlO1xuICAgICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHJldHVybiBzb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShyZXNwb25zZXMpLCBtc2dfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3J1bk1ldGhvZChwYXJzZWREYXRhLCBzb2NrZXQuX2lkLCBucyk7XG4gICAgICBpZiAoIXJlc3BvbnNlKSByZXR1cm47XG4gICAgICByZXR1cm4gc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUocmVzcG9uc2UpLCBtc2dfb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogUnVucyBhIGRlZmluZWQgUlBDIG1ldGhvZC5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlIC0gYSBtZXNzYWdlIHJlY2VpdmVkXG4gICogQHBhcmFtIHtPYmplY3R9IHNvY2tldF9pZCAtIHVzZXIncyBzb2NrZXQgaWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICAqL1xuICBhc3luYyBfcnVuTWV0aG9kKG1lc3NhZ2UsIHNvY2tldF9pZCwgbnMgPSBcIi9cIikge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCksXG4gICAgICAgIGlkOiBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLmpzb25ycGMgIT09IFwiMi4wXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgSlNPTiBSUEMgdmVyc2lvblwiKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAoIW1lc3NhZ2UubWV0aG9kKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMiwgXCJNZXRob2Qgbm90IHNwZWNpZmllZFwiKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UubWV0aG9kICE9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCwgXCJJbnZhbGlkIG1ldGhvZCBuYW1lXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLnBhcmFtcyAmJiB0eXBlb2YgbWVzc2FnZS5wYXJhbXMgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLm9uXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyZTMpLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICAgIGNvbnN0IGV2ZW50X25hbWVzID0gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpO1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnRfbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcInByb3ZpZGVkIGV2ZW50IGludmFsaWRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlLmV2ZW50c1tldmVudF9uYW1lc1tpbmRleF1dLnByb3RlY3RlZCA9PT0gdHJ1ZSAmJiBuYW1lc3BhY2UuY2xpZW50cy5nZXQoc29ja2V0X2lkKVtcIl9hdXRoZW50aWNhdGVkXCJdID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNiksXG4gICAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRfaW5kZXggPSBuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0uc29ja2V0cy5pbmRleE9mKHNvY2tldF9pZCk7XG4gICAgICAgIGlmIChzb2NrZXRfaW5kZXggPj0gMCkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcInNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIHN1YnNjcmliZWQgdG8gZXZlbnRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0uc29ja2V0cy5wdXNoKHNvY2tldF9pZCk7XG4gICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcIm9rXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdHMsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMub2ZmXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyZTMpLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwicHJvdmlkZWQgZXZlbnQgaW52YWxpZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0uc29ja2V0cy5pbmRleE9mKHNvY2tldF9pZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJub3Qgc3Vic2NyaWJlZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnNvY2tldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwib2tcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5sb2dpblwiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UucGFyYW1zKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNCksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbWVzc2FnZS5tZXRob2RdKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAxKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICBpZiAodGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0ucHJvdGVjdGVkID09PSB0cnVlICYmIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKVtcIl9hdXRoZW50aWNhdGVkXCJdID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNSksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbWVzc2FnZS5tZXRob2RdLmZuKFxuICAgICAgICBtZXNzYWdlLnBhcmFtcyxcbiAgICAgICAgc29ja2V0X2lkXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQpIHJldHVybjtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IC0zMmUzLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkXG4gICAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbWVzc2FnZS5pZCkgcmV0dXJuO1xuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMubG9naW5cIiAmJiByZXNwb25zZSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgcyA9IHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKTtcbiAgICAgIHNbXCJfYXV0aGVudGljYXRlZFwiXSA9IHRydWU7XG4gICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuc2V0KHNvY2tldF9pZCwgcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgcmVzdWx0OiByZXNwb25zZSxcbiAgICAgIGlkOiBtZXNzYWdlLmlkXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBHZW5lcmF0ZSBhIG5ldyBuYW1lc3BhY2Ugc3RvcmUuXG4gICogQWxzbyBwcmVyZWdpc3RlciBzb21lIHNwZWNpYWwgbmFtZXNwYWNlIG1ldGhvZHMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgKi9cbiAgX2dlbmVyYXRlTmFtZXNwYWNlKG5hbWUpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbmFtZV0gPSB7XG4gICAgICBycGNfbWV0aG9kczoge1xuICAgICAgICBfX2xpc3RNZXRob2RzOiB7XG4gICAgICAgICAgZm46ICgpID0+IE9iamVjdC5rZXlzKHRoaXMubmFtZXNwYWNlc1tuYW1lXS5ycGNfbWV0aG9kcyksXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xpZW50czogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIGV2ZW50czoge31cbiAgICB9O1xuICB9XG59O1xudmFyIFJQQ19FUlJPUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFstMzJlMywgXCJFdmVudCBub3QgcHJvdmlkZWRcIl0sXG4gIFstMzI2MDAsIFwiSW52YWxpZCBSZXF1ZXN0XCJdLFxuICBbLTMyNjAxLCBcIk1ldGhvZCBub3QgZm91bmRcIl0sXG4gIFstMzI2MDIsIFwiSW52YWxpZCBwYXJhbXNcIl0sXG4gIFstMzI2MDMsIFwiSW50ZXJuYWwgZXJyb3JcIl0sXG4gIFstMzI2MDQsIFwiUGFyYW1zIG5vdCBmb3VuZFwiXSxcbiAgWy0zMjYwNSwgXCJNZXRob2QgZm9yYmlkZGVuXCJdLFxuICBbLTMyNjA2LCBcIkV2ZW50IGZvcmJpZGRlblwiXSxcbiAgWy0zMjcwMCwgXCJQYXJzZSBlcnJvclwiXVxuXSk7XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihjb2RlLCBkZXRhaWxzKSB7XG4gIGNvbnN0IGVycm9yID0ge1xuICAgIGNvZGUsXG4gICAgbWVzc2FnZTogUlBDX0VSUk9SUy5nZXQoY29kZSkgfHwgXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICB9O1xuICBpZiAoZGV0YWlscykgZXJyb3JbXCJkYXRhXCJdID0gZGV0YWlscztcbiAgcmV0dXJuIGVycm9yO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBDbGllbnQgPSBjbGFzcyBleHRlbmRzIENvbW1vbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MgPSBcIndzOi8vbG9jYWxob3N0OjgwODBcIiwge1xuICAgIGF1dG9jb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdF9pbnRlcnZhbCA9IDFlMyxcbiAgICBtYXhfcmVjb25uZWN0cyA9IDUsXG4gICAgLi4ucmVzdF9vcHRpb25zXG4gIH0gPSB7fSwgZ2VuZXJhdGVfcmVxdWVzdF9pZCkge1xuICAgIHN1cGVyKFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgYWRkcmVzcyxcbiAgICAgIHtcbiAgICAgICAgYXV0b2Nvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgICBtYXhfcmVjb25uZWN0cyxcbiAgICAgICAgLi4ucmVzdF9vcHRpb25zXG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVfcmVxdWVzdF9pZFxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuZXhwb3J0cy5Db21tb25DbGllbnQgPSBDb21tb25DbGllbnQ7XG5leHBvcnRzLkRlZmF1bHREYXRhUGFjayA9IERlZmF1bHREYXRhUGFjaztcbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5leHBvcnRzLmNyZWF0ZUVycm9yID0gY3JlYXRlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/dist/index.cjs\n");

/***/ })

};
;